{
  "name": "replay",
  "description": "When API testing slows you down: record and replay HTTP responses like a boss",
  "version": "1.6.0",
  "author": {
    "name": "Assaf Arkin",
    "email": "assaf@labnotes.org",
    "url": "http://labnotes.org/"
  },
  "keywords": [
    "test",
    "testing",
    "mock",
    "stub",
    "http",
    "replay",
    "vcr",
    "api"
  ],
  "main": "./lib/replay",
  "directories": {
    "doc": "./doc",
    "lib": "./lib"
  },
  "scripts": {
    "prepublish": "make build",
    "test": "./node_modules/.bin/mocha"
  },
  "dependencies": {},
  "devDependencies": {
    "coffee-script": "~1.3.3",
    "express": "~2.5.11",
    "mocha": "~1.6.0",
    "async": "~0.1.22",
    "request": "~2.11.4"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/assaf/node-replay"
  },
  "bugs": {
    "url": "https://github.com/assaf/node-replay/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/assaf/node-replay/blob/master/MIT-LICENSE"
    }
  ],
  "readme": "# Node Replay\n   \n\n### When API testing slows you down: record and replay HTTP responses like a boss\n\nThings that will ruin your day when tests make HTTP requests to other services:\n\n- That other service has the uptime of Twitter's API\n- Network late ............ ncy\n- Being-rate limited and having to wait an hour for the next test run\n- Same request returns different result each time\n- Everyone else on the network is deep in BitTorrent terittory\n\nThings **node-replay** can do to make these problems go away:\n\n- Record API response once, replay as often as necessary\n- Stub HTTP requests (TBD)\n- Replay different responses to same request (great for testing error handling)\n- Not suck\n\n\n## How to use node-replay\n\nLike this:\n\n```\n$ npm install replay\n```\n\nNow write some simple test case:\n\n```\nassert = require(\"assert\")\nhttp = require(\"http\")\nreplay = require(\"replay\")\n\nhttp.get({ hostname: \"www.iheartquotes.com\", path: \"/api/v1/random\" }, function(response) {\n  response.body = \"\";\n  response.on(\"data\", function(chunk) {\n    response.body = response.body + chunk;\n  })\n  response.on(\"end\", function() {\n\n    // Now check the request we made to the I <3 Quotes API\n    assert.equal(response.statusCode, 200);\n    assert.equal(response.body, \"Oxymoron 2. Exact estimate\\n\\n[codehappy] http://iheartquotes.com/fortune/show/38021\\n\");\n    console.log(\"Woot!\");\n\n  })\n})\n```\n\nThis, of course, will fail the first time you run it.  You'll see:\n\n```\nError: Connection to http://www.iheartquotes.com:80/api/v1/random refused: not recording and no network access\n    at Array.0 (/Users/assaf/projects/node-replay/lib/replay/proxy.coffee:87:21)\n    at EventEmitter._tickCallback (node.js:192:40)\n```\n\nUnless you tell it otherwise, **node-replay** runs in `replay` mode.  In this\nmode it will replay any previously captured HTTP response, but it will not allow\nany outgoing network connection.\n\nThat's the default mode for running tests.  \"Why?\" you ask.  Good question.\nRunning in `replay` mode forces any test you run to use recorded reponses, and\nso it will run (and fail or pass) the same way for anyone else, any other day of\nthe week, on whatever hardware they use.  Even if they're on the AT&T network.\n\nRunning in `replay` mode helps you write repeatable tests.  Repeatable tests are\na Good Thing.\n\nSo the first thing you want to do to get that test to pass, is to run\n**node-replay** in `record` mode.  In this mode it will replay any recorded\nresponse, but if no response was recorded, it will make a request to the server\nand capture the response.\n\nLet's do that:\n\n```\n$ REPLAY=record node test.js\n```\n\nThat wasn't too hard, but the test is still failing.  \"How?\" you must be\nwondering and scratching your head in total disbelief.  It's actually quite\nsimple.\n\nEvery request you make to 'I 3> Quotes' returns a different quote, and that test\nis looking for a very specific quote.  So the test will fail, and each time fail\nwith a different error.\n\nSo one way we can fix this test is to change the assertion.  Look at the error\nmessage, get the actual quote and make the assertion look for that value.\n\nNow run the test:\n\n```\n$ node test.js\nWoot!\n```\n\nDid the test pass?  Of course it did.  Run it again.  Still passing?  Why, yes.\n\nSo let's have a look at that captured response.  All the respones recorded for\n'I <3 Quotes>' will be listed here:\n\n```\n$ ls fixtures/www.iheartquotes.com/\n```\n\nThere should be only one file there, since we only recorded one response.  The\nfile name is a timestamp, but feel free to rename it to something more\nrescriptive.\n\nThe name of a response file doesn't matter, it can be whatever you want.  The\nname of the directory does, though, it matches the service hostname (and port\nwhen not 80).\n\nSo that was one way to fix the failing test.  Another one is to change the\nrecorded response to match the assertion.  Being able to edit (and create new)\nresponses is quite important.  Sometimes it's the easiest way to create mock\nresponses for testing, e.g. if you're trying to test failure conditions that are\nhard to come by.\n\nSo let's edit the response file and change the body part, so the entire response\nreads like this:\n\n```\n/api/v1/random\n\n200 HTTP/1.1\nserver: nginx/0.7.67\ndate: Fri, 02 Dec 2011 02:58:03 GMT\ncontent-type: text/plain\nconnection: keep-alive\netag: \"a7131ebc1e81e43ea9ecf36fa2fdf610\"\nx-ua-compatible: IE=Edge,chrome=1\nx-runtime: 0.158080\ncache-control: max-age=0, private, must-revalidate\ncontent-length: 234\nx-varnish: 2274830138\nage: 0\nvia: 1.1 varnish\n\nOxymoron 2. Exact estimate\n\n[codehappy] http://iheartquotes.com/fortune/show/38021\n```\n\nAll responses are stored as text files using the simplest format ever, so you\ncan edit them in Vim, or any of the many non-Vim text editors in existence:\n\n- First comes the request path (including query string)\n- Followed by any headers sent as part of the request (like `Accept` and `Authorization`)\n- Then an empty line\n- Next the response status code and (optional) HTTP version number\n- Followed by any headers sent as part of the response\n- Then another empty line\n- And the rest taken by the response body\n\nIf you need to use regular expressions to match the request URL, add `REGEXP`\nbetween the method and path, for example:\n\n```\nGET REGEXP /\\/Aregexp\\d/i\n\nHTTP/1.1\nContent-Type: text/html\n```\n\n\n## Settings\n\nWe've got them.  Just enough to make you happy and not enough to take all day to\nexplain.\n\nThe first and most obvious is the mode you run **node-reply** in:\n\n**bloody** -- All requests go out, none get replayed.  Use this if you want to\nremember what life was before you started using **node-replay**.  Also, to test\nyour code against changes to 3rd party API, because these do happen.  Too often.\n\n**cheat** -- Replays recorded responses, and allow HTTP outbound requests.  This\nis mighty convenient when you're writing new tests or changing code to make new,\nun-recorded HTTP requests, but you haven't quite settled on which requets to\nmake, so you don't want any responses recorded quite yet.\n\n**record** -- Replays recorded responses, or captures responses for future\nreplay.  Use this whenever you're writing new tests or code that makes new HTTP\nrequests.\n\n**replay** -- Replays recorded responses, does not allow outbound requests.\nThis is the default node.  That's another way of saying, \"you'll be running in\nthis mode most of the time\".\n\nYou can set the mode by setting the environment variable `REPLAY` to one of\nthese values:\n\n```\n$ REPLAY=record node test.js\n```\n\nOf from your code by setting `replay.mode`:\n\n```\nvar Replay = require(\"replay\");\nReplay.mode = \"record\"\n```\n\nOf course, **node-reply** needs to store all those captured responses somewhere,\nand by default it will put them in the directory `fixtures`.  Bet you have an\nidea for a better directory name.  Easy to change.\n\nLike this:\n\n```\nReplay.fixtures = __dirname + \"/fixtures/replay\"\n```\n\nYou can tell **node-replay** what hosts to treat as \"localhost\".  Requests to\nthese hosts will be routed to 127.0.0.1, without capturing or replay.  This is\nparticularly useful if you're making request to a test server and want to use\nthe same URL as production.\n\nFor example:\n\n```\nReplay.localhost \"www.example.com\"\n```\n\nThere may be hosts you don't care to record/replay: it doesn't matter if\nrequests to these hosts succeed or not, and you don't care to manage their\nrecorded file.  You can just add those to the ignore list:\n\n```\nReplay.ignore \"www.google-analytics.com\", \"airbrake.io\"\n```\n\nLikewise, you can tell **node-reply** to allow network access to specific hosts:\n\n```\nReplay.allow \"logger.example.com\"\n```\n\nRequests to allowed and ignored hosts will still replay any previously recorded\nresponses, but if there is no recorded response, they will either fail (ignored)\nor pass through to the actual server (allowed).\n\nIf you're running into trouble, try turning debugging mode on.  It helps.\nSometimes.\n\n```\n$ DEBUG=true node test.js\nRequesting http://www.iheartquotes.com:80/api/v1/random\nWoot!\n```\n\n\n## Geeking\n\nTo make all that magic possible, **node-replay** replaces\n`require('http').request` with its own method.  That method returns a\n`ProxyRequest` object that captures the request URL, headers and body.\n\nWhen it's time to fire the request, it gets sent through a chain of proxies.\nThe first proxy to have a response, returns it (via callback, this is Node.js\nafter all).  That terminates the chain.  A proxy that doesn't have a response\nstill has to call the callback, but with no arguments.  The request will then\npass to the next proxy down the chain.\n\nThe proxy chain looks something like this:\n\n- Logger dumps the request URL when running with `DEBUG=true`\n- The pass-through proxy will pass the request directly to the server in `bloody` mode, or when talking to `localhost`\n- The recorder proxy will either replay a captured request (if it has one), talk to the server and capture the response\n  (in `record` mode), or pass to the next proxy\n- The pass-through proxy (2nd one) will pass the request to the server in `cheat` mode, return nothing in all other\n  modes\n\nLoading pre-recorded responses to memory, from where they can be replayed, and\nstoring new ones on disk, is handled by ... cue big band ... the `Catalog`.\n\n\n## Final words\n\n**node-replay** is released under the MIT license.  Pull requests are welcome.\n\n",
  "readmeFilename": "README.md",
  "_id": "replay@1.6.0",
  "_from": "replay@1.6.0"
}
